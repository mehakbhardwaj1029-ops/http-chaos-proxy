In this section i will write down about some confusions that someone can i while building this project.

1. Why are we calling this as a reverse proxy ? Does it works only for the responses that are going to be received by client (request <- reverse proxy <- client)?

The answer to that would be no.

Lets see a basic idea of what are forward and reverse proxies?

You can associate proxy to intentional fake client or server.

Forward Proxy - Client Side Proxy - Represents Client

It is configured by client 
The client knows that it is using a proxy.
Server has no idea about Client Side Proxy.

Ex - Browser
Browser is configured with proxy settings, browser can choose where to send requests.
It is used for firewalls, VPNs

Reverse Proxy - Server Side Proxy - Represents Server

Only the server knows about it.
Ex - Used for Load balancing, Rate limiting, Chaos testing(this project), Security

So, since now we know basic idea of what a forward and reverse proxy does , we can come to a conclusion that ,the proxy we developed is reverse because client is sending request to "port 1234" and has no idea that actually request are getting processed on sever running on "port 9090".
The server client is giving request to is actually trying to break every request you give it instead of performing business logic.

NOTE - direction of flow of request does not make a proxy forward or reverse.


2. What is the purpose of this intentional breaking ?
If requests are delayed or failed, how does this help? Won’t APIs just break? 

Answer to that would be that the whole point is to just "break the API" because in real time systems:
Services crash
Networks are slow
Database becomes unavailable ... n no. of potential failures.

So just looking for a OK response is not going to work , we have to test our system for the time when it might break because it will break at sometime.

`200 OK - looks good but it is not the only point
`

"Proxy is not fixing anything in your system , It is revealing weaknesses"

It helps you find answer to the questions:
* Does my API retry correctly?
* Does it timeout?
* Does it degrade gracefully?
* Does it return fallback responses?
* Does it prevent cascading failures?

`Without chaos testing your service you assume that it is going to work but chaos proxy works to prove your assumption wrong`

Ex- 

Payment → Chaos Proxy → Inventory

We will test When our payment and inventory service might fail , and how are they dealing with that failure
